\section{IntroducciÃ³n}

C is an efficient, portable, powerful, and flexible programming language, oriented to programmers.

Advantages of C programmes: small, fast, reliable, easy to learn and understand.

\subsection{Fundamentals of a programme}

The basic operations of a computer form the computer's instruction set. To solve a problem using a computer, you must provide a solution by sending instructions to the instructions set. So, a computer programme sends the instructions to solve a certain problem to the instructions set.

The approach or method used to solve the problem is an algorithm. Then if there is a programme that tests if a number is odd or even.
\begin{itemize}
    \item The statements that solve the problem are the program.
    \item The methods used to verify if the number is even or odd is the algorithm.
\end{itemize}

The instructions to implement the algorithm are expressed in a partircular computer language, such as Java, C++ or C.

CPU (Central Processing Unit) is the brain of the computer, where most of computing work is done and the instructions are executed.

The RAM (Random Access Memory) stores the data of the programme while it's running.

The hardware drive is the permanent storages, that stores files that contain programme source code, even while computer is off.

An OS (Operating System) controls the operation of the computer: input, output, computer resources, execution of programmes. It makes it more convenient to use computers. E.g.: Windows, iOS...

A fetch or Execute Cycle fetches an instruction from memory using registers and executes it in a loop. A 1 GHz CPU can do this loop 1 billion times a second. This cycle can be seen below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Figures/1_Introduction/Execute_cycle.png}
    \caption{Execute cycle}
    \label{fig:ExeCycle}
\end{figure}

At the lowest level, a programme is merely interacting with the CPU.

Higher-level programming languages make it easier to write programmes. They describe actions in a more abstract form. The instructions of these programmes are like problem-solving steps. They allow the programmer not to worry about the particular steps followed by CPU.

A compiler translates the high-level languages into the machine languages instructions. They also check if a programme has a valid syntax. If there is a syntax error, it finds it and report back to the programmer.

The act of writing a C programme can be broken down into multiple steps:
\begin{enumerate}
    \item \textbf{Define programme objectives:} Understand the requirements of the programme and get a clear idea of what you want the programme to acomplish.
    \item \textbf{Design the programme:} Decide how to meet the requirements, define the user interface and organise the programme.
    \item \textbf{Write the code:} Translate the design in the syntax of C. A text editor is used to create a source code.
    \item \textbf{Compile:} Translate it into machine code
    \item \textbf{Run the programme:} An executable file is a programme that can be run.
    \item \textbf{Test and debug the programme:} Check if the programme works as supposed, finding and fixing errors.
    \item \textbf{Maintain and modify the programme:} Fix new bugs and add new features.
\end{enumerate}

The above steps can be jumped around and repeated.

Many new programmers ignore the first two steps, which is a mistake. I should develop the habit of planning before coding, which long-term saves a lot of time.

You always want to work in small steps and test constantly a few lines.

\subsection{Overview}

C is a general purpose, imperative (states what to do instead of asking questions) computer programming language that supports structured programming. This is in contrast to languages like MATLAB which are created for specific applications.

C is a modern language: it has most basic control structures and features of modern languages, is designed for top-down planning, is organised around functions (modular design) and is very reliable and readable.

C is widely used and is the preferred language for producing word processing programmes, compilers, etc. It is popular for programming embedded systems.

C programmes are easy to modify and adapt to new models of languages. It is a subset of C++ with object-oriented programming tools, which means that knowing C means that you know much of C++. 

C provides constructs that efficiently map to typical machine instructions. It provides low-level access to memory (it has many low-level capabilities) and requires minimal run-time support. 

C evolved from a previous programming language, B, adding data typing and other features. Is available for most computers and independent of hardware, being versatile.

There are many variations of C, which means that a Standard C version had to be created. A programme written in Standard C without hardware-dependent assumptions will run correctly on any platform with a standard C compiler. Non-standard C programmes may run only on certain platforms or compilers.

C89 (created in 1989) is the basis of most C codes. C99 is a revised standard of C that refines and expands its capabilities, but it has not been widely adopted. C11 (2011) is the current standard, with additional optional features, and the classes are based on this standard.

\subsection{Language features}

C produces compact and efficient programmes and is one of the most important programming languages. The main features of C are:
\begin{itemize}
    \item Efficient.
    \item Flexible.
    \item Powerful and Flexible.
    \item Programmer Oriented.
\end{itemize}

C is efficient because it takes advantage of the capabilities of current computers, its programmes are compact and fast and programmers can fine-tune their programmes for maximum speed or most efficient use of memory.

C is portable because its programmes written in one system can be run in other systems with little or no modificacion. Besides, compilers are available for many computer architectures.

The Linux kernel (the brain of the CPU, contains the interfaces with hardware, manages memory...), compilers and interpreters for other languages are usually written in C, C is used for solving physics and engineering problems... This speaks for itself for the power of the C language.

C is flexible since it is used for developing every kind of programme, is a basis for other languages, such as C++... However, there is a trade-off between flexibility and performance, since a high flexibility can cause bugs or the developers not to understand certain concepts.

C is easy to learn because of its compactness, being ideal as a first language to learn.

C fulfils the needs of programmers, since it gives access to hardware and enables to manipulate individual bits in memory. It contains a large selection of operators which allows to express yourself succinctly. This may be a danger, since you can make mistakes impossible to make in other languages. C have a large library of useful C functions that deal with common needs of most probrammers.

Other features of C are that provides low level features generally provided by lower level languages, the fact that programmes can be manipulated using bits and pointers play a big role in C.

The main disadvantages of C are that the programmer has an extra responsability for the freedom that he has and its conciseness may turn a C programme difficult to understand sometimes.

\subsection{Creating a C programme}

There are four fundamental tasks in the creation of a C programme: editing, compiling, linking, and executing. 

Editing is the process of creating and modifying your source code. A simple editor like a notepad can be used, but it is better to use an IDE (Integrated Development Environment), with several facilities for the programmers. The IDE used for the course is CodeBlocks.

Compiling converts the code into machine languages and detects and reports syntax errors. Is a two-stage process: preprocessing (the code may be modified or added) and the actual compilation that generates the object code. The compiler examines each programme statement and checks it to ensure that it is consistent with the syntax and semantics of the language. Can recognise structural errors (dead code that is not being used), does not find logic errors, and the typical errors reported are syntactic errors (unbalanced parentheses in an expression) or semantic errors (use of a variable not defined).

After the errors are fixed, the compiler will translate it into assembly language and then into actual machine instructions. The output of the compiler is an object code and is stored in files called object files (same name as source file with a .obj or a .o extension). 

The standard command to compile a C program will be cc (or gcc for the GNU compiler). The typical instruction is \textbf{cc -c myprog.c}. If omit -c, the programme will automatically be linked as well. In CodeBlocks there is an option in the menu to compile.

The purpose of the linking is to get the programme in a final form for execution by the computer. Usually occurs automatically when compiling, but sometimes can be a separated command. There are one or several .obj from compiling and you turn them into an executable. Also detect and reports errors if a part of the programme is missions or a non-existent library component is referenced. It includes libraries into the executable.

A failure in linking means that you have to go back and edit the source code. Success will produce an executable file; in Windows, it will be a .exe. Many IDEs have a buid option to compile and link the programme in a single operation to obtain the executable.

A programme of significant size will consist of several source code files. The programme is much easier to manage by breaking it up in smaller source files: it is cohesive and makes the development and maintenance much easier. The set of source files will usually be integrated under a project name, which usually refers to the whole programme.

The execution can be performed by double clicking on the executable. Each of the statements is executed sequentially. If data is needed, the programme temporarily suspends execution so that the input can be entered. The results (output) are displayed in a window called the console. The execution can generate a wide variety of errors: wrong outputs, doing nothing or crashing the computer. If there is an error, it is necessary to go back and reanalyse the programme, which is called debugging.

The entire process of compiling, linking and executing the programme must be repeated until the desired results are obtained.

\section{Installing Required Software}

\subsection{Overview}

For Windows, the necessary software to install are a C compiler (Cygwin for this course) and an IDE (CodeLite).

\subsection{Installing the C compiler}

The components to install are: a GNU gcc compiler, make and ddb debugger from cygwin.com, which simulates a unix environment.

After selecting them in the installer and installing them, you must go to the directory of installation of Cygwin, go to bin, and copy the path. Then, you go to "This PC", right-click, and select properties. Then you go to advanced system settings, select environment variables, go to the list of system variables, and select path. A new window is opened, where you click on new and paste the path previously copied. 

To check that it has been done correctly, you open the command window and type "cygcheck -c cygwin". It has to appear the package cygwin, the version, and that the status is ok. Then you type "gcc --version" and the version of the gcc compiler has to appear.

\subsection{Installing CodeLite}

CodeLite can be downloaded from codlite.org.

\subsection{Configuring CodeLite}

The compiler has to be added manually to CodeLite by clicking in Settings -$>$ Build Settings -$>$ + (add an existing compiler). Then you have to go to the folder of cygwin64 installed, go to bin folder and add it. Then you hace to select the C compiler (gcc.exe), the assembler name (as.exe), the linker (gcc.exe), the Shared Object Linker (gcc.exe -shared -fPIC), the archive (ar.exe rcu), the make (make.exe -j16, it should be correct) and gdb (gdb.exe).

To create a new workspace, you have to click in new workspace and select a C++ workspace. The folder in which the workspace will be created is important that does not have any space, \& and special characters that can create problems. When creating a new workspace, the tick of "Create the workspace under a separate directory" must be activated.

The workspace is where the C projects are to be created. The projects are created by clicking at the workspace and select New -$>$ New Project. Then the categories of the new project must be filled:
\begin{itemize}
    \item \textbf{Category:} The normal programmes are Console. A GUI, a Library and other types of programmes are other options, but usually it will be Console programmes.
    \item \textbf{Type:} Usually it will be a Simple executable (gcc). 
    \item \textbf{Compiler:} Select the name of the compiler previously added (Cygwin for me).
    \item \textbf{Debugger:} GNU gdb debugger is the only choice.
    \item \textbf{Build System:} Select CodeLite MakeFile Generator -UNIX.
\end{itemize}

The red ball that appears in a programme open means that there are non-saved changes.

The tool icon that appears under the Workspace and Explorer tags is for changing the project settings.

To compile a programme, you have to go to Build -$>$ Build Project.

Ctrl+S is the shortcut to saving a programme.

To run a programme, you have to go to Build -$>$ Run.

In the window below of the CodeLite application, the two most important tabs are build (compiler, says if an error occurs when compiling) and output (where the results of a run are shown).

\subsection{Creating a default CodeLite Project Template}

It is important to select in the project settings -$>$ Compiler options the option of Enable C99 features to access some features of this version of C. and in Linker options the option of static.

To avoid the process of selecting the project settings each time that a new workspace is created, you can click on the project folder and select Save as template. You select a name (without spaces or special characters), the category of User templates and you can add a description if desired.

Then, when creating a new project, in the category you select User templates and then in type the name of the template that you saved previosuly. The new project will have all the settings of the project used for template.

When you have several projects, the active project of the workspace is highlighted in \textbf{bold} letter. You make a project active by right-click -$>$ Make Active or by double-click the folder.

Another option that appears when right-click a folder is to rename a project.

\subsection{Using the Command Line Interface}

The IDE is no necessary, you can use a text editor, a terminal window or an installer C compiler to run and compile C programmes.

You can open a terminal window of cygwin by typing cygwin of Windows and selecting the option that appears. 

The main directory of this terminal is C:$\backslash$cygwin64$\backslash$home$\backslash$daer.

A text in Notepad can be saved as a C programme by saving it as AllFiles and add to the name at the end a .c.

By typing ls in the terminal window, you can see what files are in your current directory. The current directory can be changed by cd and a new folder can be created by using mkdir. The command more prints what is written in the C file and clear clears the window.

To see where the gcc compiler is you can write which gcc and to see the version you can write gcc --version. To compile a file in your current directory you type gcc and the name of the .c file. If the compilation is correct, the prompt will come back inmediately with no messages. Now a new executable has been created since there is no compile errors, usually called a.exe. If you type ./a or ./a.exe (if the name is different, change a for the name of the executable), the programme will be executed. If there is a compile error, the command window will point the line of the error.

The name of the exe generated by the compiler can be changed by typing gcc (.c name).c -o and the name of the executable that you want.

With gcc --help you can see the instructions of all possible commands.

\subsection{Using a Web-based C compiler}

There is the possibility of using online C compilers to create, compile and run C programmes. The most famous is OnlineGDB Beta. It is usually the first option that appears in Google when searching online C compiler. It has the option of write, run, debug and save programmes.

Other option is the Online C Compiler from Tutorialspoint. It has more limited options but it may have some performance problems. Another C compiler is the one of Programiz.

Finally, CS50 IDE is an online IDE that uses Gitlab (needed for its use) to save the programmes.

These online compilers may not support all the functions of the C language, but there is a nice option if you don't have access to a C compiler in the computer.

\section{Starting to write code}

\subsection{Exploring the CodeLite environment}

CodeLite is a lightweight IDE with minimal features and minimal graphical interface components compared to other IDEs such as Visual Studio. 

In Settings -$>$ Preferences several options for the configuration of CodeLite can be selected. In Folding -$>$ Show Folding Margin, the brackets are highlighted and you can hide and show the code that is contained into the brackets, which can be useful if you have a lot of code lines.

The colours of the programmes mark what are the words used. For the Dark palette of colours:
\begin{itemize}
    \item \textcolor{orange}{Orange} for header files and the strings for a printf function.
    \item \textcolor{purple}{Purple} for some of the different data types and for the return option.
    \item \textcolor{yellow}{Yellow} for numbers.
    \item \textcolor{blue}{Blue} for typical functions such as printf and for the name of the programme.
    \item White for the $\#$include options and other normal words.
\end{itemize}

In Settings -$>$ Colours and fonts these colours can be edited.

In the lower part of the workspace, between the Build and Output tags, there are options to search and replace text of the programme. 

In the right side of the workspace, there are a toolbar with the options usually performed by shortcuts such as copy, paste, cut, undo, redo... 

In view you can select which windows you want to see at each time in the workspace and hide those that you do not want to see at a certain time. The toolbar can be put at the top, the left of the bottom in this tag in MainToolBarOrientation.

The tag of search allows you to search for certain words in the file, replace them, go to a certain line, search in various files...

In Workspace you can open, close or reload workspaces, create a new project, select the active project, among other features.

In Build -$>$ Clean Workspace you can delete all the intermediate files: .o, libraries...

In Plugins there are several plugins to use, the only important usually are some for code completion.

In Help you can find answers to some questions.

The other options have already been covered or will be covered in future sections.

\subsection{Creating the first C programme}

The first thing to do when starting a new C programme is to include a header file from other C library, which is used by the command \textbf{$\#$include} and add the header file. The standard header file is $<$stdio.h$>$.

After that, the next thing that must be entered is the main function, the entry point of the programme. Forst a type of data must be written (\textbf{int} for example) and then the name of the function with their inputs between parenthesis: (input). If the function has no input, you can leave the parenthesis () or write (\textbf{void}).

If a parenthesis, square bracket [] or a curly brace {} opened has no closure, it will be highlighted red.

After the inputs, a curly brace must be opened to indicate that between them is contained the function code.

\textbf{int} before a variable declares a variable as integer.

\textbf{printf} prints something in the command window. It must end with a $\backslash$n.

\textbf{scanf} ask the user to enter a data and then stores into a variable.

After each statement, a semicolon; must be written.

\subsection{Building and compiling our first programme}

The Clean option for a programme cleans all intermediate files generated during compilation or execution: .o, libraries... It reuslts in a clean workspace that must be recompiled again. It can be useful is a compilation is generating problems in programmes with a lot of intermediate objects generated.

The difference between build and rebuild is that build compiles every programme in the workspace and rebuild only those that have changed since the previous build.

Build basically compiles and links the programme in the same step, instead of having to compile first and then link it.

The Workspace view only shows the .c and the executables of the workspace. To see all the files in it, you must click and the folder drawing in the right side and select the folder of the workspace in which you are working, showing the json, .o, makefile... 

You can use the Stop Build option if a build is taking too long and you want it to stop.

\subsection{Compiler errors}

A compiler error is an error that breaks the rules of the programming language of the compiler. They can be syntax errors or semantic errors.

A syntax error is when something is wrong with the structure of the code: missing semicolon, a parenthesis or bracket not closed, a quotation mark not closed, a forgotten $\#$ behind the include, a bad syntax of the header file stdio.h...

A semantic errors is something wrong with the meaning of a statement. For example, if a is an integer and b is a string, it does not make sense to state c = a + b;, put a string after a return.

Some of the compiler errors are not very descriptive, but at least the line of the error is clearly marked and with practice it becomes easy to identify the compiler error. If there is several errors, it returns all the errors founded. 

When having several errors, start by fixing the first one since it may be causing another errors in following lines.

\subsection{Compiler warnings}

A warning is a notification of the compiler about an found issue with the code that could lead to a potential problem, even if it is not an error.

It is only a warning because the compiler is still able to generate correct machine code and an object file, but it should not be ignored.

An example of a warning occurs when you define a variable and try to print it or do an operation with it but has not been initialised with a value. The code can be generated, but when the programme is run is very likely that it will fail because it can print a non-existent error.

Another example is an unused variable, a variable, declared, initialised but never used in the code. The programme will not likely fail, but it is dead code that uses memory and resources in a useless way.

\subsection{Linker errors}

A linker error is caused when there is a problem linking all object files together to create an executable. Typically, this means that a library or an object file is missing.

It usually appears "undefined reference to" when this type of error occurs. 

\subsection{Runtime errors}

These errors occur when the programme is executing: divide by zero, file not found, out of memory... and can cause the programme to crash.

\subsection{Logic errors}

These are errors in the code that cause the programme to run incorrectly. These are mistakes made by the programmer. For example, if you want to make a programme in which you introduce the age of a person and decide if he can vote, you have to put $>=$18, no$>$18, which can make the programme to return a non correct solution if you introduce 18.

\subsection{Structure of a C programme}

The main structure of a C programme are the following:
\begin{itemize}
    \item In the first lines, the inclusion of libraries and external programmes is done by the command \textbf{include}.
    \item Then the main function of the C programme is initialised. Is the entry point of the programme and the contents are included between {}.
    \item After that, the contents of the main function are included.
    \item If necessary, after the main function, the auxiliary functions used will be written below the end of the main function.
\end{itemize}

The readability of the programme is important for correcting errors, debugging, and for other users to understand the programme.

An important note is the uppercase and lowercase letter are different in C, so A is not the same variable as a.

\section{Basic concepts}

\subsection{Comments}

Comments are used in a programme to document it and enhance its readability. There are to remind you or someone else reading your code what the programme or a specific line is doing. The comments are ignored by the compiler. The comments are useful when you return to a programme several months later and you do not remember what the programme does.

There are two ways to add comments into a C programme:
\begin{itemize}
    \item Using the characters / and *. It is used for multi-line comments. These types of comments have to be terminated. The opening of the comment is marked with /* and the end with */. All characters between these are treated as part of the comment.
    \item Using //. The comment goes from the // to the end of the line. It does not have to be closed. It is used for single-line comments.
\end{itemize}

An example in the use of these two types of comments is the following:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{Figures//4_Basic_Concepts/Comments use example}
    \caption{Comments use example}
    \label{fig:comments_use}
\end{figure}

If there are many comments, the readability of a programme may decrease instead of improve, so the comments need to be intelligently used. It is a good habit to insert comments statements into the programme as it is being written: it eases to document the programme when you have the logic in your head, and it helps with the debugging.

Using meaningful names help to self-document the code without using too many comments.

When you want to comment a part of the code, you can select those lines and use Ctrl+Shift+7 or go to Edit -$>$ Comment and select Comment selection.

\subsection{Preprocessor}

A preprocessor is a unique feature of C that is not found in other programmes. It allows process to be easier to develop, read, modify and port to different computer systems. The preprocessor is a part previous to the compilation of the programme that recognises special statements and analyses them. It gives an instruction to your compiler to do something before compiling the source code.

The commands of the preprocessor are usually at the beginning of the programme, but they could be anywhere in it. 

Preprocessor statements are identified by the pressence of a pund sign $\#$, which must be the first non-space character on the line. The directive \textbf{\#include} is an example of it.

The preprocessor is used to create constants (a data that never can change in the code) and macros with the \textbf{\#define} statement, build your own library files with the \textbf{\#include} statement and make more powerful programms with the statements \textbf{\#ifdef}, \textbf{\#endif}, \textbf{\#else} and \textbf{\#ifndef}.

\subsection{The include statement}

The statement \textbf{\#include} is an example of a preprocessor directive. The example on the initial programmes were $\#$include $<$stdio.h$>$. It is similar to the import statement in Java.

In the previous example, the compiler is instructed to include in the programme the contents of the file with the name stdio.h, which is called a header file because it is usually included at the head of a programme. The extension of these header files is.h.

The header files define information about some of the functions provided by the files. stdio.h is the standard C library header and provides functionality for displaying output, among many other things. We need to include this file in a programme when using the printf() function. stdio is short for standard input/output. stdio.h contains the information that the compiler needs to understand what printf() and other functions that deal with input and output mean.

Header files specify information that the compiler uses to integrate any predefined function within a programme. You will be creating your own header files for use in your programmes.

The header files should always be written in lowercase. There are two ways to include the header files:
\begin{itemize}
    \item Using angle brackets: \textbf{\#include $\mathbf{<}$stdio.h$\mathbf{>}$}. This tells the preprocessor to look for the file in one or more standard system directories.
    \item Using double quotes: \textbf{\#include $\mathbf{"}$stdio.h$\mathbf{"}$}. This tells the preprocessor to first look in the current directory.
\end{itemize}

Every C compiler that conforms to the C11 standard will have a set of standard header files supplied.

You should use \textbf{$\mathbf{\#}$ifndef} and \textbf{$\mathbf{\#}$define} to ptrotect against multiple inclusions of a header file, so that the preprocessor does not enter the header file on multiple occasions unnecessarily.

The typical syntax is: a header, definition of some types, structures... and the functions that it includes.

Executable code normally goes into a source code file, not a header file.

\subsection{Display output}

\textbf{printf()} is a standard library function that outputs information to the command line based on what appears between its parenthesis. The line of use of the function must end in a semicolon.

This is probably the most common function used in C. It provides an easy and convenient mean to display programme results, since it can print variables and results of computations. It can also be used for debugging.

\subsection{Reading input from the terminal}

It is very useful to ask the user to enter data into a programme via the terminal. The C library contains several input functions, being \textbf{scanf()} the most general of them since it can read a variety of formats.

\textbf{scanf()} reads the input from the standard input stream stdin and scans that input according to the format provided. Format can be a simple constant strings, but you can specify \%s, \%d, \%c, and \%f to read strings, integer, character or floats.

\textbf{scanf()} is similar to \textbf{printf()} since both use a cnotrol string followed by a list of argument. The control string indicates the destination data types for the input stream of characters. However, \textbf{prinf()} uses variable names, constants and expressions as its argument list, but \textbf{scanf()} uses pointers to variables (although you don't need to know anything about pointers to use it).

There are three rules about \textbf{scanf()}:
\begin{itemize}
    \item It returns the number of items that it successfully reads.
    \item If it is used to read a value for one of the basic variable types discussed, precede the variable name with an \&.
    \item If it is used to read a string into a character array, don't use \&. 
\end{itemize}

\textbf{scanf()} uses whitespace (newlines, tabs, spaces) to decide how to devide the input into separate fields. 

When a programme uses \textbf{scanf()} to gather input from the keyboard, it waits for you to input text. To read the input introduced, you must press Enter.

\textbf{scanf()} expects input in the same format as fou provided. If you gave the function \%s and \%d, it will expect an string followed by a number, not any other combination.

To read a double variable, the specified type of the function \textbf{scanf()} is \%lf.